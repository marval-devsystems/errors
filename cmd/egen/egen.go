package main

import (
	"encoding/json"
	"fmt"
	"go/format"
	"hash/fnv"
	"log"
	"os"
	"strconv"
	"strings"
)

var (
	defaultFolder = "."

	errorsConst = `// Code generated by github.com/marval-devsystems/errors, DO NOT EDIT.
package econst`
)

type errorJson struct {
	Err        string            `json:"error"`
	HttpStatus int               `json:"http_status"`
	Msg        map[string]string `json:"msg"`
}

func main() {
	errJson, err := parseErrJson()
	if err != nil {
		log.Fatalf("failed %v", err)
	}

	if len(errJson) == 0 {
		log.Fatal("file must contain at least one error")
	}

	econst, eWebJson := genErrData(errJson)

	errWebJson, err := json.MarshalIndent(eWebJson, "", "    ")
	if err != nil {
		log.Fatalf("failed encode web errors: %v", err)
	}

	formatedErrWebJson, err := format.Source([]byte(fmt.Sprintf("%s\n\n%s", errorsConst, econst)))
	if err != nil {
		log.Fatalf("failed format: %v", err)
	}

	if err := saveFile("econst.go", formatedErrWebJson); err != nil {
		log.Fatalf("failed save econst.go: %v", err)
	}

	if err := saveFile("errors.response.json", errWebJson); err != nil {
		log.Fatalf("failed save errors.response.json: %v", err)
	}
}

func saveFile(filename string, data []byte) error {
	if err := os.WriteFile(fmt.Sprintf("%s/%s", getDir(), filename), data, 0644); err != nil {
		return err
	}

	return nil
}

func parseErrJson() ([]errorJson, error) {
	data, err := os.ReadFile(getDir() + "/errors.json")
	if err != nil {
		return nil, fmt.Errorf("read file: %v", err)
	}

	var errJson []errorJson

	if err := json.Unmarshal(data, &errJson); err != nil {
		return nil, fmt.Errorf("parse file: %v", err)
	}

	return errJson, nil
}

func genErrData(errJson []errorJson) (string, map[uint32]map[string]string) {
	var econst string

	econstHttpStatus := make([]string, 0, len(errJson))

	eWebJson := make(map[uint32]map[string]string, len(errJson))

	for i := range errJson {
		errJson[i].Err = strings.TrimSpace(errJson[i].Err)

		if !validateErrText(errJson[i].Err) {
			continue
		}

		code := getUniqKey(errJson[i].Err)

		varible := strings.Join(strings.Split(strings.Title(strings.ToLower(errJson[i].Err)), " "), "")

		econst = fmt.Sprintf("%s%s uint32 = %d \n", econst, varible, code)

		if errJson[i].Msg == nil {
			errJson[i].Msg = make(map[string]string, 1)
		}

		if _, ok := errJson[i].Msg["en"]; !ok {
			errJson[i].Msg["en"] = upperFirst(errJson[i].Err)
		}

		eWebJson[code] = errJson[i].Msg

		httpStatus := errJson[i].HttpStatus
		if httpStatus < 100 || httpStatus > 999 {
			httpStatus = 500
		}

		econstHttpStatus = append(econstHttpStatus, fmt.Sprintf("%d: {\"status\": %d, \"text\": \"%s\"}", code, httpStatus, errJson[i].Msg["en"]))
	}

	econst = fmt.Sprintf("const (%s) \n var HttpResponse = map[uint32]map[string]interface{}{\n%s,\n}", econst, strings.Join(econstHttpStatus, ",\n"))

	return econst, eWebJson
}

func validateErrText(errStr string) bool {
	if errStr == "" {
		return false
	}

	word := []rune(errStr)

	if _, err := strconv.Atoi(string(word[0])); err == nil {
		return false
	}

	return true
}

func upperFirst(errStr string) string {
	words := strings.Split(errStr, " ")
	word := []rune(words[0])

	firstWord := fmt.Sprintf("%s%s", strings.ToUpper(string(word[0])), string(word[1:]))

	if len(words) == 1 {
		return firstWord
	}

	return fmt.Sprintf("%s %s", firstWord, strings.Join(words[1:], " "))
}

func getUniqKey(errStr string) uint32 {
	hash := fnv.New32a()
	hash.Write([]byte(errStr))
	return hash.Sum32()
}

func getDir() string {
	dir := defaultFolder

	if len(os.Args) > 1 {
		dir = os.Args[1]
	}

	return dir
}
